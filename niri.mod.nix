# inputs that are available before the whole configuration has been built

# consider pkgs. it needs to know what system is being used which is specified as a direct input to nixosSystem function
# this then 



/* identify this flake's inputs and make sure that all of those have their outputs available
now we import all the n.mod.nix files and run their functions with other flake's outputs. we dont have access to anything generated by our flake
some processing of the resulting nix expressions leads to a list of modules and home_modules.
these modules can be functions that take inputs. These inputs can be various things 
  - other flake outputs by passing them through to specialArgs or extraSpecialArgs for home manager. Note self does not give access to inputs
  - self, which is this flake which gives access to other outputs of this flake. this is practicaly giving access to other outputs inside an output. 
  - config, 

*/

{ niri, ags_system, ... }:
{
  universal.modules = [
    niri.nixosModules.niri

    (
      { pkgs, ... }:
      {
        programs.niri.enable = true;
        nixpkgs.overlays = [ niri.overlays.niri ];
        programs.niri.package = pkgs.niri-unstable;
      }
    )
  ];

  universal.home_modules = [
    
  ];

}




{config, ...}:
{
    programs.niri.settings = {
        input.keyboard.xkb.layout = "se";

        layout = {
            default-column-width = { proportion = 1.0; };
            gaps = 0;
            preset-column-widths = [
                { proportion = 1. / 3.; }
                { proportion = 1. / 2.; }
                { proportion = 2. / 3.; }
                #{ proportion = 1.0; }

                # { fixed = 1920; }
            ];
            focus-ring = {
              enable = false;
            #   width = 10000;
            #   active.color = "#00000055";
            };

        };
        spawn-at-startup = [
            {command = ["${ags_system.packages.x86_64-linux.default}/bin/my-shell"];}
        ];


        binds = with config.lib.niri.actions; {
            "Mod+T".action = spawn "alacritty";
            "Mod+D".action = spawn "fuzzel";
            "Mod+Q".action =  close-window;
            "Mod+O".action = spawn "ags" "request" "toggle";

            "Mod+Left".action = focus-column-left;
            "Mod+Right".action = focus-column-right;
            "Mod+Down".action =  focus-window-down;
            "Mod+Up".action = focus-window-up;
            "Mod+H".action = focus-column-left;
            "Mod+L".action = focus-column-right;
            "Mod+J".action = focus-window-down;
            "Mod+K".action = focus-window-up;

            "Mod+Ctrl+Left".action =move-column-left;
            "Mod+Ctrl+Down".action = move-window-down;
            "Mod+Ctrl+Up".action = move-window-up;
            "Mod+Ctrl+Right".action = move-column-right;
            "Mod+Ctrl+H".action = move-column-left;
            "Mod+Ctrl+J".action = move-window-down;
            "Mod+Ctrl+K".action = move-window-up;
            "Mod+Ctrl+L".action = move-column-right;

            "Mod+F".action = maximize-column;
            "Mod+Shift+F".action = fullscreen-window;

            "Mod+R".action = switch-preset-column-width;
            "Mod+Shift+R".action = switch-preset-window-height;


            "Mod+Shift+S".action = screenshot; # {write-to-disk = true;};
            #"Ctrl+Print".action.screenshot-screen = {write-to-disk = true;};
            #"Alt+Print".action.screenshot-window = {write-to-disk = true;};

            # Powers off the monitors. To turn them back on, do any input like
            # moving the mouse or pressing any other key.
            "Mod+Shift+P".action = power-off-monitors;

            # The quit action will show a confirmation dialog to avoid accidental exits.
            "Mod+Shift+E".action = quit;
        };
        # spawn-at-startup = [];
    };
}